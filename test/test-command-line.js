// Copyright (c) 2016 Intel Corporation. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

'use strict';

/* global describe, it */
var assert = require('assert');
var exec = require('child_process').exec;
var execSync = require('child_process').execSync;
var Util = require('./Util.js');
var widlParser = require('webidl2');
var fs = require('fs');
var fsExtra = require('fs-extra');
var rimraf = require('rimraf');

var execPath = '../node_modules/.bin/widl-nan ';
var sampleWidlPath = './test/command-line/sample.widl';
var helperFileNames = [
  'array_helper.h',
  'generator_helper.h',
  'promise-helper.h',
  'thread-event-helper.h',
  'thread-event-helper.cpp',
  'widl_dictionary_helper.h'
];

describe('help option check', function() {
  it('#widl-nan -h', function(done) {
    exec(execPath + ' -h', (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      var bool = stdout.indexOf('Usage:');
      assert.equal(bool > 0, true);
      done();
    });
  });

  it('#widl-nan -help', function(done) {
    exec(execPath + ' -help', (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      var bool = stdout.indexOf('Usage:');
      assert.equal(bool > 0, true);
      done();
    });
  });
});

describe('version option check', function() {
  it('#widl-nan -V', function(done) {
    exec(execPath + ' -V', (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      var re = /[0-9].[0-9].[0-9]/;
      var bool = stdout.match(re);
      assert.equal(bool !== -1, true);
      done();
    });
  });

  it('#widl-nan --version', function(done) {
    exec(execPath + ' --version', (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      var re = /[0-9].[0-9].[0-9]/;
      var bool = stdout.match(re);
      assert.equal(bool !== -1, true);
      done();
    });
  });
});

describe('normal check', function() {
  it('#widl-nan sample.widl', function(done) {
    var tmpdir = Util.createTmpDir();
    var cmd = '../../' + execPath + '../../' + sampleWidlPath;
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      // check helper files
      for (var x in helperFileNames) {
        if (Util.isFile(tmpdir + '/gen/' + helperFileNames[x])) {
          assert.ok(true);
        } else {
          assert.ok(false);
        }
      }
      // check files generated by interface name
      var nodes = widlParser.parse(fs.readFileSync(tmpdir + '/../../' + sampleWidlPath, 'utf-8'));
      for (var n in nodes) {
        if (nodes[n].type === 'interface') {
          assert.equal(Util.isFile(tmpdir + '/gen/nan__' +
            nodes[n].name.toLowerCase() + '.cpp'), true);
          assert.equal(Util.isFile(tmpdir + '/gen/nan__' +
            nodes[n].name.toLowerCase() + '.h'), true);
          assert.equal(Util.isFile(tmpdir + '/gen/dont-build/' +
            nodes[n].name.toLowerCase() + '.cpp'), true);
          assert.equal(Util.isFile(tmpdir + '/gen/dont-build/' +
            nodes[n].name.toLowerCase() + '.h'), true);
        }
      }
      // check impl files
      assert.equal(Util.isFile(tmpdir + '/gen/dont-build/addon.cpp'), true);
      assert.equal(Util.isFile(tmpdir + '/gen/dont-build/binding.gyp'), true);
      rimraf.sync(tmpdir);
      done();
    });
  });
});

describe('init option check', function() {
  it('#widl-nan sample.widl;widl-nan -i', function(done) {
    var tmpdir = Util.createTmpDir();
    var cmd = '../../' + execPath + '../../' + sampleWidlPath;
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      var nodes = widlParser.parse(fs.readFileSync(sampleWidlPath, 'utf-8'));
      for (var n in nodes) {
        if (nodes[n].type === 'interface') {
          assert.equal(Util.isFile(tmpdir + '/' + nodes[n].name.toLowerCase() + '.cpp'), false);
          assert.equal(Util.isFile(tmpdir + '/' + nodes[n].name.toLowerCase() + '.h'), false);
        }
      }
      fsExtra.copySync(tmpdir + '/../../package.json', tmpdir + '/package.json');
      var cmd = '../../' + execPath + ' -i';
      exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
        if (err) {
          console.log(err);
          assert.ok(false);
          done();
        }
        for (var n in nodes) {
          if (nodes[n].type === 'interface') {
            assert.equal(Util.isFile(tmpdir + '/' + nodes[n].name.toLowerCase() + '.cpp'), true);
            assert.equal(Util.isFile(tmpdir + '/' + nodes[n].name.toLowerCase() + '.h'), true);
          }
        }
        rimraf.sync(tmpdir);
        done();
      });
    });
  });

  it('#widl-nan sample.widl;widl-nan -i -d test', function(done) {
    var tmpdir = Util.createTmpDir();
    var cmd = '../../' + execPath + '../../' + sampleWidlPath;
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      var nodes = widlParser.parse(fs.readFileSync(sampleWidlPath, 'utf-8'));
      nodes.forEach(node => {
        if (node.type === 'interface') {
          assert.equal(!Util.isFile(tmpdir + '/' + node.name.toLowerCase() + '.cpp'), true);
          assert.equal(!Util.isFile(tmpdir + '/' + node.name.toLowerCase() + '.h'), true);
        }
      });
      fsExtra.copySync(tmpdir + '/../../package.json', tmpdir + '/package.json');
      var cmd = '../../' + execPath + ' -i -d ' + tmpdir;
      exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
        if (err) {
          console.log(err);
          assert.ok(false);
          done();
        }
        for (var n in nodes) {
          if (nodes[n].type === 'interface') {
            assert.equal(Util.isFile(tmpdir + '/' + nodes[n].name.toLowerCase() + '.cpp'), true);
            assert.equal(Util.isFile(tmpdir + '/' + nodes[n].name.toLowerCase() + '.h'), true);
          }
        }
        rimraf.sync(tmpdir);
        done();
      });
    });
  });

  it('#widl-nan sample.widl;widl-nan -i twice', function(done) {
    var tmpdir = Util.createTmpDir();
    var cmd = '../../' + execPath + '../../' + sampleWidlPath;
    execSync(cmd, {cwd: tmpdir, stdio: 'ignore'});
    fsExtra.copySync(tmpdir + '/../../package.json', tmpdir + '/package.json');
    cmd = '../../' + execPath + ' -i';
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      var stat = fs.statSync(tmpdir + '/addon.cpp');
      var minute1 = stat.ctime.getMinutes();
      var second1 = stat.ctime.getSeconds();
      var millisecond1 = stat.ctime.getMilliseconds();
      var stop = new Date().getTime();
      while (new Date().getTime() < stop + 1000) {
      }
      exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
        if (err) {
          console.log(err);
          assert.ok(false);
          done();
        }
        var stat = fs.statSync(tmpdir + '/addon.cpp');
        var minute2 = stat.ctime.getMinutes();
        var second2 = stat.ctime.getSeconds();
        var millisecond2 = stat.ctime.getMilliseconds();
        if (minute1 === minute2 && second1 === second2 && millisecond1 === millisecond2) {
          assert.ok(true);
          rimraf.sync(tmpdir);
          done();
        } else {
          assert.ok(false);
          rimraf.sync(tmpdir);
          done();
        }
      });
    });
  });

  it('#widl-nan -i (without package.json)', function(done) {
    var tmpdir = Util.createTmpDir();
    var cmd = '../../' + execPath + ' -i';
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        var bool = stderr.indexOf('Error:');
        assert.equal(bool > 0, true);
        rimraf.sync(tmpdir);
        done();
      }
      assert.ok(false);
      rimraf.sync(tmpdir);
      done();
    });
  });

  it('#widl-nan -i (without gen folder)', function(done) {
    var tmpdir = Util.createTmpDir();
    fsExtra.copySync(tmpdir + '/../../package.json', tmpdir + '/package.json');
    var cmd = '../../' + execPath + ' -i';
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        var bool = stderr.indexOf('Error:');
        assert.equal(bool > 0, true);
        rimraf.sync(tmpdir);
        done();
      }
      assert.ok(false);
      rimraf.sync(tmpdir);
      done();
    });
  });

  it('#widl-nan -i (when gen is a file)', function(done) {
    var tmpdir = Util.createTmpDir();
    fsExtra.copySync(tmpdir + '/../../package.json', tmpdir + '/package.json');
    fsExtra.copySync(tmpdir + '/../../package.json', tmpdir + '/gen');
    var cmd = '../../' + execPath + ' -i';
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        var bool = stderr.indexOf('Error:');
        assert.equal(bool > 0, true);
        rimraf.sync(tmpdir);
        done();
      }
      assert.ok(false);
      rimraf.sync(tmpdir);
      done();
    });
  });
});

describe('override option check', function() {
  it('#widl-nan sample.widl;widl-nan -i;widl-nan -i -o', function(done) {
    var tmpdir = Util.createTmpDir();
    var cmd = '../../' + execPath + '../../' + sampleWidlPath;
    execSync(cmd, {cwd: tmpdir, stdio: 'ignore'});
    fsExtra.copySync(tmpdir + '/../../package.json', tmpdir + '/package.json');
    cmd = '../../' + execPath + ' -i';
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      var stat = fs.statSync(tmpdir + '/addon.cpp');
      var minute1 = stat.ctime.getMinutes();
      var second1 = stat.ctime.getSeconds();
      var millisecond1 = stat.ctime.getMilliseconds();
      var stop = new Date().getTime();
      while (new Date().getTime() < stop + 1000) {
      }
      var cmd = '../../' + execPath + ' -i -o';
      exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
        if (err) {
          console.log(err);
          assert.ok(false);
          done();
        }
        var stat = fs.statSync(tmpdir + '/addon.cpp');
        var minute2 = stat.ctime.getMinutes();
        var second2 = stat.ctime.getSeconds();
        var millisecond2 = stat.ctime.getMilliseconds();
        if (minute1 !== minute2 || second1 !== second2 || millisecond1 !== millisecond2) {
          assert.ok(true);
          rimraf.sync(tmpdir);
          done();
        } else {
          assert.ok(false);
          rimraf.sync(tmpdir);
          done();
        }
      });
    });
  });
});

describe('clean option check', function() {
  it('#widl-nan sample.widl;widl-nan -c', function(done) {
    var tmpdir = Util.createTmpDir();
    var cmd = '../../' + execPath + '../../' + sampleWidlPath;
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      exec('../../' + execPath + ' -c ', {cwd: tmpdir}, (err, stdout, stderr) => {
        if (err) {
          console.log(err);
          assert.ok(false);
          done();
        }
        assert.equal(Util.isDir(tmpdir + 'gen'), false);
        rimraf.sync(tmpdir);
        done();
      });
    });
  });

  it('#widl-nan sample.widl;widl-nan --clean', function(done) {
    var tmpdir = Util.createTmpDir();
    var cmd = '../../' + execPath + '../../' + sampleWidlPath;
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      exec('../../' + execPath + ' --clean ', {cwd: tmpdir}, (err, stdout, stderr) => {
        if (err) {
          console.log(err);
          assert.ok(false);
          done();
        }
        assert.equal(Util.isDir(tmpdir + 'gen'), false);
        rimraf.sync(tmpdir);
        done();
      });
    });
  });

  it('#widl-nan sample.widl -d test;widl-nan -c -d test', function(done) {
    var tmpdir = Util.createTmpDir();
    var cmd = '../../' + execPath + ' -d testDir ../../' + sampleWidlPath;
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      var cmd = '../../' + execPath + ' -d testDir -c ';
      exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
        if (err) {
          console.log(err);
          assert.ok(false);
          done();
        }
        assert.equal(Util.isFile(tmpdir + '/testDir/gen/dont-build/addon.cpp'), false);
        assert.equal(Util.isFile(tmpdir + '/testDir/gen/dont-build/binding.gyp'), false);
        rimraf.sync(tmpdir);
        done();
      });
    });
  });

  it('#widl-nan -c (without gen folder)', function(done) {
    var tmpdir = Util.createTmpDir();
    var cmd = '../../' + execPath + ' -c ';
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        var bool = stderr.indexOf('no such file or directory, stat \'gen\'');
        assert.equal(bool > 0, true);
        rimraf.sync(tmpdir);
        done();
      }
      assert.ok(false);
      done();
    });
  });

  it('#widl-nan -c (when gen is a file)', function(done) {
    var tmpdir = Util.createTmpDir();
    fsExtra.copySync(tmpdir + '/../../package.json', tmpdir + '/testDir');
    var cmd = '../../' + execPath + ' -d testDir -c ';
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        var bool = stderr.indexOf('exsits but not a directory');
        assert.equal(bool > 0, true);
        rimraf.sync(tmpdir);
        done();
      }
      assert.ok(false);
      done();
    });
  });
});

describe('dest option check', function() {
  it('#widl-nan sample.widl -d test', function(done) {
    var tmpdir = Util.createTmpDir();
    var cmd = '../../' + execPath + ' -d testDir ../../' + sampleWidlPath;
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      assert.equal(Util.isFile(tmpdir + '/testDir/gen/dont-build/addon.cpp'), true);
      assert.equal(Util.isFile(tmpdir + '/testDir/gen/dont-build/binding.gyp'), true);
      rimraf.sync(tmpdir);
      done();
    });
  });

  it('#widl-nan sample.widl --dest test', function(done) {
    var tmpdir = Util.createTmpDir();
    var cmd = '../../' + execPath + ' --dest testDir ../../' + sampleWidlPath;
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      // check impl files
      assert.equal(Util.isFile(tmpdir + '/testDir/gen/dont-build/addon.cpp'), true);
      assert.equal(Util.isFile(tmpdir + '/testDir/gen/dont-build/binding.gyp'), true);
      rimraf.sync(tmpdir);
      done();
    });
  });

  it('#widl-nan sample.widl -d test (absolute path)', function(done) {
    var tmpdir = Util.createTmpDir();
    var cmd = '../../' + execPath + ' -d /tmp/ ../../' + sampleWidlPath;
    if (Util.isDir('/tmp/gen/')) {
      rimraf.sync('/tmp/gen');
    }
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      // check impl files
      assert.equal(Util.isFile('/tmp/gen/dont-build/addon.cpp'), true);
      assert.equal(Util.isFile('/tmp/gen/dont-build/binding.gyp'), true);
      rimraf.sync(tmpdir);
      rimraf.sync('/tmp/gen');
      done();
    });
  });

  it('#widl-nan sample -d test (test dir is already exist)', function(done) {
    var tmpdir = Util.createTmpDir();
    var creatdir = tmpdir + '/tmpgen';
    fs.mkdirSync(creatdir);
    var cmd = '../../' + execPath + ' -d ' + creatdir + ' ../../' + sampleWidlPath;
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      // check impl files
      assert.equal(Util.isFile(creatdir + '/gen/dont-build/addon.cpp'), true);
      assert.equal(Util.isFile(creatdir + '/gen/dont-build/binding.gyp'), true);
      rimraf.sync(tmpdir);
      done();
    });
  });

  it('#widl-nan sample.widl -d test (when dest is file)', function(done) {
    var tmpdir = Util.createTmpDir();
    fsExtra.copySync(tmpdir + '/../../package.json', tmpdir + '/testDir');
    var cmd = '../../' + execPath + ' -d ' + tmpdir + '/testDir ../../' + sampleWidlPath;
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        var bool = stderr.indexOf('exsits but not a directory');
        assert.equal(bool > 0, true);
        rimraf.sync(tmpdir);
        done();
      }
      assert.ok(false);
      done();
    });
  });
});

describe('widl-nan option invalid', function() {
  it('#widl-nan --invalid', function(done) {
    var tmpdir = Util.createTmpDir();
    var cmd = '../../' + execPath + ' --invalid';
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        var bool = stderr.indexOf('unknown option');
        assert.ok(bool > 0);
        rimraf.sync(tmpdir);
        done();
      }
      assert.ok(false);
      done();
    });
  });
});

describe('widl-nan option none', function() {
  it('#widl-nan (without any option)', function(done) {
    var tmpdir = Util.createTmpDir();
    var cmd = '../../' + execPath;
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        var bool = stderr.indexOf('Need specify WebIDL files as input.');
        assert.ok(bool > 0);
        rimraf.sync(tmpdir);
        done();
      }
      assert.ok(false);
      done();
    });
  });
});

// Blocking by issue #46
// describe('widl-nan invalid widl file', function() {
//   it('#widl-nan + folder', function(done) {
//     var tmpdir = Util.createTmpDir();
//     var creatdir = tmpdir + '/tmpgen';
//     fs.mkdirSync(creatdir);
//     var cmd = '../../' + execPath + creatdir;
//     exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
//       if (err) {
//         var bool = stderr.indexOf('is not a file');
//         assert.ok(bool > 0);
//         rimraf.sync(tmpdir);
//         done();
//       }
//       assert.ok(false);
//       done();
//     });
//   });
// });

//   it('#widl-nan + invalid widl file(package.widl)', function(done) {
//     var tmpdir = Util.createTmpDir();
//     fsExtra.copySync(tmpdir + '/../../package.json', tmpdir + '/package.widl');
//     var cmd = '../../' + execPath + tmpdir + '/package.widl';
//     exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
//       if (stdout) {
//         var bool = stdout.indexOf('is not a file');
//         assert.ok(bool > 0);
//         rimraf.sync(tmpdir);
//         done();
//       }
//       assert.ok(false);
//       done();
//     });
//   });
// });

describe('widl-nan multiple widl files', function() {
  it('#widl-nan multiple true widl file test', function(done) {
    var tmpdir = Util.createTmpDir();
    fsExtra.copySync(tmpdir + '/../../test/callback/callback.widl', tmpdir + '/callback.widl');
    fsExtra.copySync(tmpdir + '/../../test/array/array.widl', tmpdir + '/array.widl');
    var cmd = '../../' + execPath + ' ../../' + sampleWidlPath + ' array.widl callback.widl';
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      // check helper files
      helperFileNames.forEach(name => {
        assert.equal(Util.isFile(tmpdir + '/gen/' + name), true);
      });
      // check files generated by interface name
      var nodes = widlParser.parse(fs.readFileSync(tmpdir + '/../../' + sampleWidlPath, 'utf-8'));
      nodes.forEach(node => {
        if (node.type === 'interface') {
          assert.equal(Util.isFile(tmpdir + '/gen/nan__' +
            node.name.toLowerCase() + '.cpp'), true);
          assert.equal(Util.isFile(tmpdir + '/gen/nan__' +
            node.name.toLowerCase() + '.h'), true);
          assert.equal(Util.isFile(tmpdir + '/gen/dont-build/' +
            node.name.toLowerCase() + '.cpp'), true);
          assert.equal(Util.isFile(tmpdir + '/gen/dont-build/' +
            node.name.toLowerCase() + '.h'), true);
        }
      });
      // check impl files
      assert.equal(Util.isFile(tmpdir + '/gen/dont-build/addon.cpp'), true);
      assert.equal(Util.isFile(tmpdir + '/gen/dont-build/binding.gyp'), true);
      rimraf.sync(tmpdir);
      done();
    });
  });

  it('#widl-nan wild has same name', function(done) {
    var tmpdir = Util.createTmpDir();
    fsExtra.copySync(tmpdir + '/../../test/callback/callback.widl', tmpdir + '/sample.widl');
    fsExtra.copySync(tmpdir + '/../../test/array/array.widl', tmpdir + '/array.widl');
    var cmd = '../../' + execPath + ' ../../' + sampleWidlPath + ' sample.widl';
    exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
      if (err) {
        console.log(err);
        assert.ok(false);
        done();
      }
      // check helper files
      helperFileNames.forEach(name => {
        assert.equal(Util.isFile(tmpdir + '/gen/' + name), true);
      });
      // check files generated by interface name
      var nodes = widlParser.parse(fs.readFileSync(tmpdir + '/../../' + sampleWidlPath, 'utf-8'));
      nodes.forEach(node => {
        if (node.type === 'interface') {
          assert.equal(Util.isFile(tmpdir + '/gen/nan__' +
            node.name.toLowerCase() + '.cpp'), true);
          assert.equal(Util.isFile(tmpdir + '/gen/nan__' +
            node.name.toLowerCase() + '.h'), true);
          assert.equal(Util.isFile(tmpdir + '/gen/dont-build/' +
            node.name.toLowerCase() + '.cpp'), true);
          assert.equal(Util.isFile(tmpdir + '/gen/dont-build/' +
            node.name.toLowerCase() + '.h'), true);
        }
      });
      // check impl files
      assert.equal(Util.isFile(tmpdir + '/gen/dont-build/addon.cpp'), true);
      assert.equal(Util.isFile(tmpdir + '/gen/dont-build/binding.gyp'), true);
      rimraf.sync(tmpdir);
      done();
    });
  });

  // blocking by issue #
  // it('#widl-nan multiple have one invalid widl', function(done) {
  //   var tmpdir = Util.createTmpDir();
  //   fsExtra.copySync(tmpdir + '/../../test/callback/callback.widl', tmpdir + '/sample.widl');
  //   fsExtra.copySync(tmpdir + '/../../package.json', tmpdir + '/invalid.widl');
  //   var cmd = '../../' + execPath + ' ../../' + sampleWidlPath + ' invalid.widl';
  //   exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
  //       console.log('===============================');
  //       console.log(err)
  //       console.log('===============================');
  //       console.log(stderr)
  //       console.log('===============================');
  //       console.log(stdout)
  //       console.log('===============================');
  //     if (err) {
  //       console.log(err);
  //       assert.ok(false);
  //       done();
  //     }
  //     // check helper files
  //     helperFileNames.forEach(name => {
  //       assert.equal(Util.isFile(tmpdir + '/gen/' + name), true);
  //     });
  //     // check files generated by interface name
  //     var nodes = widlParser.parse(fs.readFileSync(tmpdir + '/../../' + sampleWidlPath,
  //       'utf-8'));
  //     nodes.forEach(node => {
  //       if (node.type === 'interface') {
  //         assert.equal(Util.isFile(tmpdir + '/gen/nan__' +
  //           node.name.toLowerCase() + '.cpp'), true);
  //         assert.equal(Util.isFile(tmpdir + '/gen/nan__' +
  //           node.name.toLowerCase() + '.h'), true);
  //         assert.equal(Util.isFile(tmpdir + '/gen/dont-build/' +
  //           node.name.toLowerCase() + '.cpp'), true);
  //         assert.equal(Util.isFile(tmpdir + '/gen/dont-build/' +
  //           node.name.toLowerCase() + '.h'), true);
  //       }
  //     });
  //     // check impl files
  //     assert.equal(Util.isFile(tmpdir + '/gen/dont-build/addon.cpp'), true);
  //     assert.equal(Util.isFile(tmpdir + '/gen/dont-build/binding.gyp'), true);
  //     rimraf.sync(tmpdir);
  //     done();
  //   });
  // });

  // Blocking by issue #
  // it('#widl-nan sample.widl test_dir', function(done) {
  //   var tmpdir = Util.createTmpDir();
  //   var creatdir = tmpdir + '/tmpgen';
  //   fs.mkdirSync(creatdir);
  //   var cmd = '../../' + execPath + creatdir + ' ../../' + sampleWidlPath;
  //   exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
  //       console.log(tmpdir)
  //           console.log('---------------------------------')
  //           console.log(stdout)
  //           console.log('---------------------------------')
  //           console.log(stderr)
  //           console.log('---------------------------------')
  //           console.log(err)
  //     if (stdout) {
  //       var bool = stdout.indexOf('Unrecognised tokens');
  //       assert.ok(bool > 0);
  //       rimraf.sync(tmpdir);
  //       done();
  //     }
  //     assert.ok(false);
  //     done();
  //   });
  // });
});
describe('node-gyp rebuild', function() {
  it('#widl-nan sample.widl -d test_dir;widl-nan -I -d test_dir;cd test_dir;node-gyp rebuild',
    function(done) {
      this.timeout(20000);
      var tmpdir = Util.createTmpDir();
      var creatdir = tmpdir + '/tmpgen';
      fs.mkdirSync(creatdir);
      fsExtra.copySync(tmpdir + '/../../package.json', tmpdir + '/package.json');
      var cmd = '../../' + execPath + ' ../../' + sampleWidlPath + ' -d ' + creatdir;
      exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
        if (err) {
          console.log(err);
          assert.ok(false);
          done();
        }
        var cmd = '../../' + execPath + ' -i -d ' + creatdir;
        exec(cmd, {cwd: tmpdir}, (err, stdout, stderr) => {
          if (err) {
            console.log(err);
            assert.ok(false);
            done();
          }
          var cmd = ' node-gyp rebuild ';
          execSync(cmd, {cwd: creatdir, stdio: 'ignore'});
          if (err) {
            console.log(err);
            assert.ok(false);
            done();
          }
          // check files generated by interface name
          var nodes = widlParser.parse(fs.readFileSync(tmpdir + '/../../' + sampleWidlPath,
            'utf-8'));
          for (var n in nodes) {
            if (nodes[n].type === 'interface') {
              assert.equal(Util.isFile(creatdir + '/gen/nan__' +
                nodes[n].name.toLowerCase() + '.cpp'), true);
              assert.equal(Util.isFile(creatdir + '/gen/nan__' +
                nodes[n].name.toLowerCase() + '.h'), true);
              assert.equal(Util.isFile(creatdir + '/gen/dont-build/' +
                nodes[n].name.toLowerCase() + '.cpp'), true);
              assert.equal(Util.isFile(creatdir + '/gen/dont-build/' +
                nodes[n].name.toLowerCase() + '.h'), true);
            }
          }
        });
        // check impl files
        assert.equal(Util.isFile(creatdir + '/gen/dont-build/addon.cpp'), true);
        assert.equal(Util.isFile(creatdir + '/gen/dont-build/binding.gyp'), true);
        rimraf.sync(tmpdir);
        done();
      });
    });
});
